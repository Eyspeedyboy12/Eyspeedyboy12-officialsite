<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Cyberpunk Tetris</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');
        
        body {
            background-color: #050505;
            color: #00f2ff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        .neo-box {
            background: rgba(16, 16, 20, 0.8);
            border: 2px solid #00f2ff;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.2), inset 0 0 10px rgba(0, 242, 255, 0.1);
        }

        #game-canvas {
            filter: drop-shadow(0 0 5px rgba(0, 242, 255, 0.3));
        }

        .stat-label { font-family: 'Orbitron', sans-serif; font-size: 0.75rem; color: #666; }
        .stat-value { font-family: 'Orbitron', sans-serif; font-size: 1.5rem; color: #fff; text-shadow: 0 0 10px #00f2ff; }
        
        #overlay {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }

        .controls-hint kbd {
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.8rem;
            color: #00f2ff;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div class="relative flex flex-col md:flex-row gap-6 p-4 max-w-full">
        <!-- Left Sidebar: Hold -->
        <div class="flex flex-col gap-4 order-2 md:order-1">
            <div class="neo-box p-4 w-32 h-32 flex flex-col items-center justify-center">
                <span class="stat-label mb-2 uppercase tracking-widest">Hold</span>
                <canvas id="hold-canvas" width="80" height="80"></canvas>
            </div>
            
            <div class="neo-box p-4 w-32 flex-grow hidden md:flex flex-col gap-4">
                <div>
                    <span class="stat-label uppercase tracking-widest">Score</span>
                    <div id="score" class="stat-value">0</div>
                </div>
                <div>
                    <span class="stat-label uppercase tracking-widest">Level</span>
                    <div id="level" class="stat-value">1</div>
                </div>
                <div>
                    <span class="stat-label uppercase tracking-widest">Lines</span>
                    <div id="lines" class="stat-value">0</div>
                </div>
            </div>
        </div>

        <!-- Main Game -->
        <div class="relative order-1 md:order-2">
            <canvas id="game-canvas" width="300" height="600" class="neo-box"></canvas>
            
            <!-- Mobile Controls Overlay (Visible only on touch) -->
            <div id="mobile-controls" class="absolute inset-0 grid grid-cols-3 grid-rows-3 opacity-0 pointer-events-none md:hidden">
                <div class="row-start-2 col-start-1 bg-white/5 active:bg-white/10" id="btn-left"></div>
                <div class="row-start-2 col-start-3 bg-white/5 active:bg-white/10" id="btn-right"></div>
                <div class="row-start-1 col-start-2 bg-white/5 active:bg-white/10" id="btn-rotate"></div>
                <div class="row-start-3 col-start-2 bg-white/5 active:bg-white/10" id="btn-down"></div>
                <div class="row-start-3 col-start-3 bg-white/5 active:bg-white/20" id="btn-drop"></div>
                <div class="row-start-1 col-start-1 bg-white/5 active:bg-white/20" id="btn-hold"></div>
            </div>

            <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-center z-10 hidden">
                <h1 class="text-4xl font-bold mb-4 text-white uppercase tracking-tighter" id="overlay-text">PAUSED</h1>
                <button id="start-btn" class="px-8 py-3 bg-cyan-500 text-black font-bold uppercase tracking-widest hover:bg-white transition-colors">Start Game</button>
            </div>
        </div>

        <!-- Right Sidebar: Next & Controls -->
        <div class="flex flex-col gap-4 order-3">
            <div class="neo-box p-4 w-32 h-32 flex flex-col items-center justify-center">
                <span class="stat-label mb-2 uppercase tracking-widest">Next</span>
                <canvas id="next-canvas" width="80" height="80"></canvas>
            </div>

            <div class="neo-box p-4 w-48 text-xs space-y-2 hidden lg:block">
                <span class="stat-label uppercase tracking-widest mb-2 block text-center">Controls</span>
                <div class="flex justify-between font-mono"><span>Move</span> <span class="controls-hint"><kbd>←</kbd><kbd>→</kbd></span></div>
                <div class="flex justify-between font-mono"><span>Rotate</span> <span class="controls-hint"><kbd>↑</kbd></span></div>
                <div class="flex justify-between font-mono"><span>Soft Drop</span> <span class="controls-hint"><kbd>↓</kbd></span></div>
                <div class="flex justify-between font-mono"><span>Hard Drop</span> <span class="controls-hint"><kbd>Space</kbd></span></div>
                <div class="flex justify-between font-mono"><span>Hold</span> <span class="controls-hint"><kbd>C</kbd></span></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * CYBERPUNK TETRIS CORE ENGINE
         */
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;

        const COLORS = {
            I: '#00f2ff', // Cyan
            J: '#0055ff', // Blue
            L: '#ffaa00', // Orange
            O: '#ffff00', // Yellow
            S: '#00ff44', // Green
            T: '#aa00ff', // Purple
            Z: '#ff0044'  // Red
        };

        const PIECES = {
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            'J': [[1,0,0],[1,1,1],[0,0,0]],
            'L': [[0,0,1],[1,1,1],[0,0,0]],
            'O': [[1,1],[1,1]],
            'S': [[0,1,1],[1,1,0],[0,0,0]],
            'T': [[0,1,0],[1,1,1],[0,0,0]],
            'Z': [[1,1,0],[0,1,1],[0,0,0]]
        };

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-canvas');
        const holdCtx = holdCanvas.getContext('2d');

        let grid = createGrid();
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameOver = false;
        let paused = true;
        let piece = null;
        let nextPiece = null;
        let holdPiece = null;
        let canHold = true;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let particles = [];

        function createGrid() {
            return Array.from({length: ROWS}, () => Array(COLS).fill(0));
        }

        class Piece {
            constructor(type) {
                this.type = type;
                this.matrix = PIECES[type];
                this.color = COLORS[type];
                this.pos = { x: Math.floor(COLS / 2) - Math.floor(this.matrix[0].length / 2), y: 0 };
            }

            rotate() {
                const rotated = this.matrix[0].map((_, i) => this.matrix.map(row => row[i]).reverse());
                const prevX = this.pos.x;
                let offset = 1;
                const matrix = this.matrix;
                this.matrix = rotated;
                while (collide(grid, this)) {
                    this.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > this.matrix[0].length) {
                        this.matrix = matrix;
                        this.pos.x = prevX;
                        return;
                    }
                }
            }
        }

        function spawnPiece() {
            if (!nextPiece) nextPiece = new Piece(Object.keys(PIECES)[Math.floor(Math.random() * 7)]);
            piece = nextPiece;
            nextPiece = new Piece(Object.keys(PIECES)[Math.floor(Math.random() * 7)]);
            canHold = true;

            if (collide(grid, piece)) {
                gameOver = true;
                showOverlay("GAME OVER");
            }
            drawNext();
        }

        function collide(grid, piece) {
            const [m, o] = [piece.matrix, piece.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(grid, piece) {
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[y + piece.pos.y][x + piece.pos.x] = piece.color;
                    }
                });
            });
        }

        function playerDrop() {
            piece.pos.y++;
            if (collide(grid, piece)) {
                piece.pos.y--;
                merge(grid, piece);
                spawnPiece();
                gridSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            piece.pos.x += dir;
            if (collide(grid, piece)) {
                piece.pos.x -= dir;
            }
        }

        function playerHold() {
            if (!canHold) return;
            if (!holdPiece) {
                holdPiece = new Piece(piece.type);
                spawnPiece();
            } else {
                const temp = holdPiece.type;
                holdPiece = new Piece(piece.type);
                piece = new Piece(temp);
            }
            canHold = false;
            drawHold();
        }

        function playerHardDrop() {
            while (!collide(grid, piece)) {
                piece.pos.y++;
            }
            piece.pos.y--;
            merge(grid, piece);
            spawnPiece();
            gridSweep();
            updateScore();
        }

        function gridSweep() {
            let rowCount = 1;
            outer: for (let y = ROWS - 1; y >= 0; --y) {
                for (let x = 0; x < COLS; ++x) {
                    if (grid[y][x] === 0) continue outer;
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;

                score += rowCount * 10 * level;
                rowCount *= 2;
                lines++;
                if (lines % 10 === 0) {
                    level++;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                }
                
                // Add particles
                for(let i=0; i<30; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: (y-1) * BLOCK_SIZE,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1,
                        color: '#00f2ff'
                    });
                }
            }
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
            document.getElementById('lines').innerText = lines;
            document.getElementById('level').innerText = level;
        }

        function drawBlock(ctx, x, y, color, isGhost = false) {
            const px = x * BLOCK_SIZE;
            const py = y * BLOCK_SIZE;
            
            ctx.fillStyle = color;
            ctx.globalAlpha = isGhost ? 0.2 : 1.0;
            
            // Neon Block style
            ctx.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            
            if (!isGhost) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(px + 5, py + 5, BLOCK_SIZE - 10, BLOCK_SIZE - 10);
                
                // Bevel effect
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(px+1, py+1, BLOCK_SIZE-2, 3);
                ctx.fillRect(px+1, py+1, 3, BLOCK_SIZE-2);
            } else {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            }
            
            ctx.globalAlpha = 1.0;
        }

        function drawGhost() {
            const ghost = {
                matrix: piece.matrix,
                pos: { ...piece.pos },
                color: piece.color
            };
            while (!collide(grid, ghost)) {
                ghost.pos.y++;
            }
            ghost.pos.y--;
            ghost.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x + ghost.pos.x, y + ghost.pos.y, ghost.color, true);
                    }
                });
            });
        }

        function draw() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid lines
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            for(let x = 0; x <= COLS; x++) {
                ctx.beginPath(); ctx.moveTo(x * BLOCK_SIZE, 0); ctx.lineTo(x * BLOCK_SIZE, canvas.height); ctx.stroke();
            }
            for(let y = 0; y <= ROWS; y++) {
                ctx.beginPath(); ctx.moveTo(0, y * BLOCK_SIZE); ctx.lineTo(canvas.width, y * BLOCK_SIZE); ctx.stroke();
            }

            // Draw Fixed Blocks
            grid.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(ctx, x, y, value);
                });
            });

            // Draw Ghost & Active Piece
            if (piece) {
                drawGhost();
                piece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) drawBlock(ctx, x + piece.pos.x, y + piece.pos.y, piece.color);
                    });
                });
            }

            // Particles
            particles.forEach((p, i) => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                if(p.life <= 0) particles.splice(i, 1);
            });
            ctx.globalAlpha = 1.0;
        }

        function drawPreview(canvasCtx, p) {
            canvasCtx.clearRect(0, 0, 80, 80);
            if (!p) return;
            const m = p.matrix;
            const size = 15;
            const offset = (80 - m.length * size) / 2;
            m.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        canvasCtx.fillStyle = p.color;
                        canvasCtx.fillRect(offset + x * size, offset + y * size, size - 1, size - 1);
                    }
                });
            });
        }

        function drawNext() { drawPreview(nextCtx, nextPiece); }
        function drawHold() { drawPreview(holdCtx, holdPiece); }

        function update(time = 0) {
            if (paused || gameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }

            draw();
            requestAnimationFrame(update);
        }

        function showOverlay(text) {
            paused = true;
            document.getElementById('overlay-text').innerText = text;
            document.getElementById('overlay').classList.remove('hidden');
            document.getElementById('start-btn').innerText = gameOver ? "Restart" : "Resume";
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            if (gameOver) {
                grid = createGrid();
                score = 0;
                level = 1;
                lines = 0;
                updateScore();
                gameOver = false;
                holdPiece = null;
                drawHold();
            }
            paused = false;
            document.getElementById('overlay').classList.add('hidden');
            if (!piece) spawnPiece();
            lastTime = performance.now();
            update();
        });

        // Controls
        window.addEventListener('keydown', event => {
            if (gameOver) return;
            if (event.code === 'ArrowLeft') playerMove(-1);
            else if (event.code === 'ArrowRight') playerMove(1);
            else if (event.code === 'ArrowDown') playerDrop();
            else if (event.code === 'ArrowUp') piece.rotate();
            else if (event.code === 'Space') playerHardDrop();
            else if (event.code === 'KeyC') playerHold();
            else if (event.code === 'Escape') {
                if(paused) {
                    paused = false;
                    document.getElementById('overlay').classList.add('hidden');
                    lastTime = performance.now();
                    update();
                } else {
                    showOverlay("PAUSED");
                }
            }
        });

        // Mobile Controls logic
        const bindBtn = (id, fn) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); fn(); });
        };

        bindBtn('btn-left', () => playerMove(-1));
        bindBtn('btn-right', () => playerMove(1));
        bindBtn('btn-rotate', () => piece.rotate());
        bindBtn('btn-down', () => playerDrop());
        bindBtn('btn-drop', () => playerHardDrop());
        bindBtn('btn-hold', () => playerHold());

        // Check for touch device to show mobile controls
        if ('ontouchstart' in window) {
            document.getElementById('mobile-controls').classList.remove('opacity-0');
            document.getElementById('mobile-controls').classList.add('opacity-100', 'pointer-events-auto');
        }

        // Initialize
        showOverlay("CYBER TETRIS");
        drawNext();
        drawHold();
    </script>
</body>
</html>